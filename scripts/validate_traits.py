#!/usr/bin/env python3
"""
Validate trait suggestions against source sprites.

Checks performed:
  • Every opaque pixel in the 24×24 sprite is claimed by at least one trait mask.
  • No trait mask references a transparent pixel.
  • Each unique colour present in the sprite has a non-empty, consistent colour name.
  • Palette coverage is reported for every unique colour.

Exit code is non-zero when any validation fails.
"""

from __future__ import annotations

import argparse
import csv
import sys
from collections import Counter, defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Set, Tuple

from PIL import Image

OPAQUE_THRESHOLD = 16


@dataclass
class TraitRecord:
    sprite_id: str
    category: str
    variant_hint: str
    color_hex: str
    color_name: str
    pixel_mask: str


def derive_layer_key(record: TraitRecord) -> str | None:
    category = record.category or ""
    if category in {"Palette", "PaletteFull", "Unassigned"}:
        return None
    hint = record.variant_hint or ""
    if not hint:
        return f"{category}::unnamed"
    parts = hint.split("_")
    if len(parts) == 1:
        return parts[0]
    if category == "Jewelry" and len(parts) >= 3 and parts[1].startswith("Earring"):
        return "_".join(parts[:3])
    if category == "Face" and parts[1] == "MouthAccessory" and len(parts) >= 3:
        return "_".join(parts[:3])
    if category == "FaceAccessory" and len(parts) >= 3 and parts[1].startswith("Earpiece"):
        return "_".join(parts[:3])
    return "_".join(parts[:2])


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Validate trait suggestions coverage and naming.")
    parser.add_argument(
        "--traits-csv",
        default=Path("data/trait_suggestions.csv"),
        type=Path,
        help="CSV file generated by analyze_traits.py",
    )
    parser.add_argument(
        "--sprite-dir",
        default=Path("data/punks_24px"),
        type=Path,
        help="Directory containing 24×24 sprite PNGs.",
    )
    parser.add_argument(
        "--fail-on-warning",
        action="store_true",
        help="Treat warnings (e.g., colour naming collisions) as failures.",
    )
    return parser.parse_args()


def parse_pixel_mask(mask: str) -> Set[Tuple[int, int]]:
    if not mask:
        return set()
    coords: Set[Tuple[int, int]] = set()
    for token in mask.split(";"):
        token = token.strip()
        if not token:
            continue
        try:
            row_str, col_str = token.split(",")
            coords.add((int(row_str), int(col_str)))
        except ValueError:
            raise ValueError(f"Invalid coordinate '{token}' in mask '{mask[:60]}...'")
    return coords


def load_trait_records(path: Path) -> Dict[str, List[TraitRecord]]:
    if not path.exists():
        raise FileNotFoundError(f"Trait CSV not found: {path}")
    by_sprite: Dict[str, List[TraitRecord]] = defaultdict(list)
    with path.open(newline="", encoding="utf-8") as handle:
        reader = csv.DictReader(handle)
        for row in reader:
            sprite_id = row["sprite_id"]
            record = TraitRecord(
                sprite_id=sprite_id,
                category=row["category"],
                variant_hint=row["variant_hint"],
                color_hex=row["color_hex"] or "",
                color_name=row["color_name"] or "",
                pixel_mask=row.get("pixel_mask", ""),
            )
            by_sprite[sprite_id].append(record)
    return by_sprite


def collect_sprite_pixels(path: Path) -> Tuple[Set[Tuple[int, int]], Counter]:
    if not path.exists():
        raise FileNotFoundError(f"Sprite missing: {path}")
    with Image.open(path) as img:
        arr = img.convert("RGBA")
        width, height = arr.size
        opaque_pixels: Set[Tuple[int, int]] = set()
        colour_counter: Counter = Counter()
        for y in range(height):
            for x in range(width):
                r, g, b, a = arr.getpixel((x, y))
                if a < OPAQUE_THRESHOLD:
                    continue
                opaque_pixels.add((y, x))
                colour_counter[(r, g, b)] += 1
    return opaque_pixels, colour_counter


def validate_sprite(
    sprite_id: str,
    records: Iterable[TraitRecord],
    sprite_root: Path,
    fail_on_warning: bool,
) -> Tuple[bool, List[str]]:
    """Returns (success, messages)."""
    messages: List[str] = []
    success = True

    sprite_path = sprite_root / f"{sprite_id}.png"
    try:
        opaque_pixels, colour_counter = collect_sprite_pixels(sprite_path)
    except FileNotFoundError as exc:
        messages.append(f"[ERROR] {exc}")
        return False, messages

    mask_union: Set[Tuple[int, int]] = set()
    mask_errors: List[str] = []
    hex_to_names: Dict[str, Set[str]] = defaultdict(set)
    palette_hexes: Set[str] = set()
    logical_groups: Dict[str, List[TraitRecord]] = defaultdict(list)
    skin_pixels: Set[Tuple[int, int]] = set()
    hair_pixels: Set[Tuple[int, int]] = set()
    headwear_pixels: Set[Tuple[int, int]] = set()
    eye_pixels: Set[Tuple[int, int]] = set()

    for record in records:
        if record.color_hex:
            hex_to_names[record.color_hex.lower()].add(record.color_name)
        if record.category == "Palette":
            if record.color_hex:
                palette_hexes.add(record.color_hex.lower())
            continue
        if record.category == "PaletteFull":
            if record.color_hex:
                palette_hexes.add(record.color_hex.lower())
            continue

        layer_key = derive_layer_key(record)
        if layer_key:
            logical_groups[layer_key].append(record)

        mask = parse_pixel_mask(record.pixel_mask)
        if not mask:
            continue
        unexpected_pixels = {coord for coord in mask if coord not in opaque_pixels}
        if unexpected_pixels:
            success = False
            sample = ", ".join(f"{r},{c}" for r, c in sorted(unexpected_pixels)[:5])
            mask_errors.append(
                f"[ERROR] {sprite_id} → {record.category} '{record.variant_hint}' "
                f"references {len(unexpected_pixels)} transparent pixels (e.g., {sample})"
            )
        mask_union |= mask
        if record.category == "Base" and record.variant_hint.startswith("Base_Skin"):
            skin_pixels |= mask
        if record.category == "Hair":
            hair_pixels |= mask
        if record.category == "Headwear":
            headwear_pixels |= mask
        if record.category == "Face" and record.variant_hint.startswith("Face_Eyes"):
            eye_pixels |= mask

    if mask_errors:
        messages.extend(mask_errors)

    missing_pixels = opaque_pixels - mask_union
    if missing_pixels:
        success = False
        sample = ", ".join(f"{r},{c}" for r, c in sorted(missing_pixels)[:10])
        messages.append(
            f"[ERROR] {sprite_id} → {len(missing_pixels)} opaque pixels unassigned "
            f"(e.g., {sample})"
        )

    # Validate colour naming coverage and consistency.
    colour_name_issues: List[str] = []
    for (r, g, b), count in colour_counter.items():
        hex_code = f"#{r:02x}{g:02x}{b:02x}"
        lower = hex_code.lower()
        names = hex_to_names.get(lower)
        if not names:
            issue = (
                f"[ERROR] {sprite_id} → colour {hex_code} "
                f"({count} px) has no associated colour name."
            )
            colour_name_issues.append(issue)
            success = False
            continue
        if len(names) > 1:
            issue = (
                f"[{'ERROR' if fail_on_warning else 'WARN'}] {sprite_id} → colour {hex_code} "
                f"has inconsistent names: {sorted(names)}"
            )
            colour_name_issues.append(issue)
            if fail_on_warning:
                success = False
    messages.extend(colour_name_issues)

    # Report palette coverage gaps as warnings.
    palette_missing = {
        f"#{r:02x}{g:02x}{b:02x}": count
        for (r, g, b), count in colour_counter.items()
        if f"#{r:02x}{g:02x}{b:02x}".lower() not in palette_hexes
    }
    if palette_missing:
        issue = (
            f"[{'ERROR' if fail_on_warning else 'WARN'}] {sprite_id} → "
            f"{len(palette_missing)} colours missing from palette entries "
            f"({', '.join(list(palette_missing)[:6])}{'…' if len(palette_missing) > 6 else ''})"
        )
        messages.append(issue)
        if fail_on_warning:
            success = False

    overlap_with_hair = skin_pixels & (hair_pixels | headwear_pixels)
    if overlap_with_hair:
        success = False
        sample = ", ".join(f"{r},{c}" for r, c in sorted(overlap_with_hair)[:10])
        messages.append(
            f"[ERROR] {sprite_id} → Skin overlaps hair/headwear at {len(overlap_with_hair)} pixels (e.g., {sample})"
        )
    eye_overlap = eye_pixels & (hair_pixels | headwear_pixels)
    if eye_overlap:
        success = False
        sample = ", ".join(f"{r},{c}" for r, c in sorted(eye_overlap)[:10])
        messages.append(
            f"[ERROR] {sprite_id} → Eyes overlap hair/headwear at {len(eye_overlap)} pixels (e.g., {sample})"
        )

    for layer_key, layer_records in logical_groups.items():
        if len(layer_records) <= 1:
            continue
        success = False
        detail = ", ".join(
            f"{rec.variant_hint} ({rec.color_hex or 'no colour'})" for rec in layer_records
        )
        messages.append(
            f"[ERROR] {sprite_id} → layer '{layer_key}' emitted {len(layer_records)} entries: {detail}"
        )

    return success, messages


def main() -> int:
    args = parse_args()
    records_by_sprite = load_trait_records(args.traits_csv)

    overall_success = True
    total_sprites = len(records_by_sprite)
    print(f"Validating {total_sprites} sprites...")

    for sprite_id, records in sorted(records_by_sprite.items()):
        success, messages = validate_sprite(sprite_id, records, args.sprite_dir, args.fail_on_warning)
        if not success:
            overall_success = False
        for message in messages:
            print(message)

    if overall_success:
        unique_hexes = {
            record.color_hex.lower()
            for records in records_by_sprite.values()
            for record in records
            if record.color_hex
        }
        print(
            f"Validation passed ✔︎ "
            f"(sprites={total_sprites}, unique_colours={len(unique_hexes)})"
        )
        return 0

    print("Validation failed ✖")
    return 1


if __name__ == "__main__":
    raise SystemExit(main())

